# -*- coding: utf-8 -*-
"""
Created on 2013-2014

Author : Edouard Cuvelier
Affiliation : UniversitÃ© catholique de Louvain - ICTEAM - UCL Crypto Group
Address : Place du Levant 3, 1348 Louvain-la-Neuve, BELGIUM
email : firstname.lastname@uclouvain.be
"""

import gmpy
import math
################## AHO Commitment ############################
##############################################################
# These commitment schemes come from
# Abe, Haralambiev and Okhubo : Signing on elements in bilinear groups for modular protocol design, 2010.
# and
# Abe, Haralambiev and Okhubo :Group to group commitment do not shrink, 2012.
##############################################################

from Crypto.Random.random import randint
import mathTools.pairing as pairing
import mathTools.otosEC as oEC
import tools.utils as utils
import tools.fingexp as fingexp
import nizkproofs.nizkpok


#nizk = nizkproofs.nizkpok


class PPATSPublicParameters(fingexp.FingExp) :
    def __init__(self,P1,P2,Pair,PUsed = 'Tate',psi=None,optim=True,Jcoord = False):
        '''
        P1 is a generator of G1
        Q2 is a generator of G2' homomorph to G2 generated by psi(Q)
        Pairing is a class object of Pairing containing information about the
        pairing that is used
        psi is the map between G2' and G2
        if psi is not None, we use the TatePairing with P in EFp and psi(Q) in EFp12
        if optim is True, the setting assumes we work in Fp,Fp2 Fp12 with precise
        tower construction and optimised operations.
        Set optim to False for more general otpions
        '''

        assert isinstance(Pair,pairing.Pairing)

        self.Pair = Pair
        self.order = Pair.r # Order of the groups of the pairings
        self.optim = optim
        self.Jcoord = Jcoord
        self.PUsed = PUsed
        if self.PUsed == 'Tate' :
            # This pairing takes P in EFp and psi(Q) in EFp12
            if not self.optim :
                self.e = Pair.TatePairing
            else:
                self.e = oEC.OptimTatePairing
        elif self.PUsed == 'Ate' :
            if not self.optim :
                self.e = Pair.AtePairing
            else :
                self.e = oEC.OptimAtePairing
        assert not self.e==None

        self.g = P2 # Generator of G2' homomorphic to G2
        self.h = P1 # Generator of G1
        if self.Jcoord :
            self.g.toJcoord()
            self.h.toJcoord()
        if psi == None:
            def psi(a):
                return a
        self.psi = psi
        # either psi: G2'---> G2 ; Pairing.Q = psi(h) is generator of G2
        # either psi is identity

        self.to_fingerprint = ["Pair","order","optim","PUsed","g","h"]
        self.to_export = {"fingerprint": [],"value": ["Pair","order","optim","Pused","g","h"]}


    def __eq__(self, other):
       return (self.g == other.g and self.h == other.h and self.Pair == other.Pair and self.psi == other.psi)

    def __str__(self):
        return "PPATSPublicParameters :\n "+str(self.Pair)

class PPATSPublicKey(fingexp.FingExp) :
    def __init__(self,PPATSpp,g1,h1,maxexp=16):
        self.PPATSpp = PPATSpp
        self.g1 = g1 # in G2'
        self.h1 = h1 # in G1
        self.maxexp = maxexp
        Jcoord = self.PPATSpp.Jcoord
        if Jcoord :
            self.g1.toJcoord()
            self.h1.toJcoord()

        self.ehg = self.PPATSpp.e(self.PPATSpp.h,self.PPATSpp.psi(self.PPATSpp.g),self.PPATSpp.Pair,Jcoord)
        self.ehgt = oEC.toTupleFp12(self.ehg) # tuple version of egh1

        #self.tripletsList = []

        #lkq = len(bin(self.h1.EFq.F.q))
        w = 10
        m = len(utils.binn(self.PPATSpp.order))
        #m = 160
        d = int(math.ceil(float(m)/w))
        e = int(math.ceil(float(d)/2))

        # Precomputed tables to fasten the scalr multiplication with the generators
        self.precomp_g = oEC.prec_comb2_EFp2(w,m,self.PPATSpp.g,Jcoord),w,m,d,e
        self.precomp_h = oEC.prec_comb2_EFp(w,m,self.PPATSpp.h,Jcoord),w,m,d,e
        self.precomp_g1 = oEC.prec_comb2_EFp2(w,m,self.g1,Jcoord),w,m,d,e
        self.precomp_h1 = oEC.prec_comb2_EFp(w,m,self.h1,Jcoord),w,m,d,e

        self.to_fingerprint = ["PPATSpp","g1","h1"]
        self.to_export = {"fingerprint": [],"value": ["PPATSpp","g1","h1"]}


    def __eq__(self, other):
       return (self.PPATSpp == other.PPATSpp and self.g1 == other.g1 and self.h1 == other.h1 and self.hashf == other.hashf)

    def random(self,*args):
        ''' Regardless of the arguments args, this method returns a random integer
            between 1 and r (the base field order)
        '''
        order = self.PPATSpp.order
        return int(randint(1,int(order)))

    def hashf(self,L):
        ''' Return a number in Zq computed from a list L of elements
            Assuming that all elements of the list has a fingerprint
        '''
        order = self.PPATSpp.order
        f = fingexp.fingerprint(L)
        z = utils.b64tompz(f)%order
        return z

    def encrypt(self,m,r=None,s=None):
        ''' Outputs a PPATSCiphertext on m using r as the randomness for the
        commitment and s as the randomness for the encryption
        '''
        #limit = 2**self.maxexp
        #assert m < limit
        #assert m >= 0
        order = self.PPATSpp.order
        if r == None:
            r = randint(1,int(order))
        if s == None:
            s = randint(1,int(order))
        # notations
        g1 = self.g1
        ECG = g1.ECG
        Jcoord = self.PPATSpp.Jcoord

        # commitment part
        d,r = self.commit(m,r)
        #d = (r*h)+(m*h1)

        # encryption part
        c1t = oEC.mul_comb2_EFp2(ECG,s,self.precomp_g,Jcoord)
        c1 = oEC.toEFp2(ECG,c1t,Jcoord)
        #c1 = s*g
        rgt = oEC.mul_comb2_EFp2(ECG,r,self.precomp_g,Jcoord)
        sg1t = oEC.mul_comb2_EFp2(ECG,s,self.precomp_g1,Jcoord)
        c2t = oEC.addEFp2(ECG,rgt,sg1t,Jcoord)
        c2 = oEC.toEFp2(ECG,c2t,Jcoord)
        #c2 = (r*g)+(s*g1)

        return PPATSCiphertext(d,c1,c2,self)

    def commit(self,m,r=None):
        ''' Output a commitment on m using randomness r
            Return the randomness used in the proof
        '''
        order = self.PPATSpp.order
        if r == None:
            r = randint(1,int(order))
        # notations
        h1 = self.h1
        ECG = h1.ECG
        Jcoord = self.PPATSpp.Jcoord
        m = m%order
        r = r%order

        rh = oEC.mul_comb2_EFp(ECG,r,self.precomp_h,Jcoord)
        mh1 = oEC.mul_comb2_EFp(ECG,m,self.precomp_h1,Jcoord)
        dt = oEC.addEFp(ECG,rh,mh1,Jcoord)

        d = oEC.toEFp(ECG,dt,Jcoord)


        return PPATSCommitment(d,self),r
    """
    def addCommitments(self,com1,com2):
        #return PPATSCommitment(com1.d+com2.d,self)
        return com1+com2
    """
    def encryptwithproofs(self,m, r=None, s=None, mp=None, rp=None, sp=None,  b=None, u=None, t=None):
        ''' Output a ciphertext on m using randomness r and s; output a proof of consistency
        using randomness mp,rp,sp ; output a proof of verifiability using randomness b,u,t.
        '''
        order = self.PPATSpp.order
        if r == None:
            r = randint(1,int(order))
        if s == None:
            s = randint(1,int(order))

        c = self.encrypt(m,r,s)
        d = self.derivCom(c)
        cproof = nizkproofs.nizkpok.consitencyProof(self,c,m,r,s,mp,rp,sp)
        vproof = nizkproofs.nizkpok.verifiabilityProof(self,d,m,r,b,u,t)

        return c,cproof,vproof

    def encryptwithCproof(self,m,r=None,s=None,mp=None,rp=None,sp=None):
        ''' Outputs a PPATSCiphertext and a consistency on m using r as the randomness for the
        commitment and s as the randomness for the encryption
         If provided, mp,rp,sp are used for the proof of consistency
        '''
        order = self.PPATSpp.order
        if r == None:
            r = randint(1,int(order))
        if s == None:
            s = randint(1,int(order))

        c = self.encrypt(m,r,s)
        cproof = nizkproofs.nizkpok.consitencyProof(self,c,m,r,s,mp,rp,sp)

        return c,cproof

    def encryptwithVproof(self,m,r=None,s=None,b=None,u=None,t=None):
        ''' Return a PPATS ciphertext together with a proof on the commitment part
            of this ciphertext. The proof ensures that the commitment is on 0 or 1
        '''
        order = self.PPATSpp.order
        if r == None:
            r = randint(1,int(order))

        c = self.encrypt(m,r,s)
        d = self.derivCom(c)
        vproof = nizkproofs.nizkpok.verifiabilityProof(self,d,m,r,b,u,t)
        return c,vproof

    def derivCom(self,c):
        ''' Return the commitment part of the ciphertext
        '''
        assert isinstance(c,PPATSCiphertext)
        return c.d

    def verify(self,c,m,a):
        ''' Given a ciphertext c, a message m and an opening a,
        the method verifies that the commitment contained in
        the ciphertext is consistent.
        Note that the opening is not equal to the randomness used to compute
        the commitment.
        The method computes two pairing.
        '''
        assert isinstance(c,PPATSCiphertext)

        return self.verifyOpening(self.derivCom(c),m,a)


    """
    def verifyBatch(self,D,M,A):
        ''' Given a list of commitments D with the correspond opening lists M and A
            this method return True if every verification suceeds and False
            otherwise
        '''
        #notations
        g = self.PPATSpp.g
        h1 = self.h1

        l = len(D)
        assert l == len(M) and l == len(A)
        Dt = h1.EFq.infty
        Mt = 0
        At = g.EFq.infty

        for i in range(l):
            epsilon = self.random()
            Dt = Dt+(epsilon*D[i])
            Mt = Mt+(epsilon*M[i])
            At = At+(epsilon*A[i])

        return self.verifyOpening(Dt,Mt,At)
    """

    def verifyCommitment(self,com,m,r):
        ''' The method verifies that com is a commitment on m using randomness r.
        '''
        assert isinstance(com,PPATSCommitment)
        com1, r = self.commit(m,r)
        return com == com1

    def verifyOpening(self,com,m,a):
        ''' The method verifies that the commitment com commits on m with respect
            to the opening a.
        '''
        # notoations
        g = self.PPATSpp.g
        h = self.PPATSpp.h
        ECG = h.ECG
        Jcoord = self.PPATSpp.Jcoord
        order = self.PPATSpp.order
        e = self.PPATSpp.e
        Pair = self.PPATSpp.Pair

        psi = self.PPATSpp.psi

        psia = psi(a)
        psig = psi(g)
        comdt = oEC.toTupleEFp(com.d,Jcoord)
        mmh1t = oEC.mul_comb2_EFp(ECG,(-m)%order,self.precomp_h1,Jcoord)
        ddt = oEC.addEFp(ECG,comdt,mmh1t,Jcoord)
        dd = oEC.toEFp(ECG,ddt,Jcoord)
        #dd = com.d-(m*h1)
        return e(h,psia,Pair) == e(dd,psig,Pair)

    def multiplicationCommitFromTriplet(self,a1,a2,a3,m1,m2):
        ''' This method builds a commitment d3 based on three precomputed commitments
        a1,a2,a3 such that a1 commits (m_a-m1),a2 commits on (m_b-m2) and a3 commits
        on some m_a*m_b+..., the output is d3 that commits on m_a*m_b
        but it does not perform any verification whatsoever
        '''
        Jcoord = self.PPATSpp.Jcoord
        ECG = self.h1.ECG
        order = self.PPATSpp.order
        a1dt = oEC.toTupleEFp(a1.d,Jcoord)
        a2dt = oEC.toTupleEFp(a2.d,Jcoord)
        a3dt = oEC.toTupleEFp(a3.d,Jcoord)
        m2a1dt = oEC.mulECP(ECG,a1dt,m2,False,Jcoord)
        m1a2dt = oEC.mulECP(ECG,a2dt,m1,False,Jcoord)
        m1m2h1t = oEC.mul_comb2_EFp(ECG,(m1*m2)%order,self.precomp_h1,Jcoord)

        a1t = oEC.addEFp(ECG,m2a1dt,m1a2dt,Jcoord)
        a2t = oEC.addEFp(ECG,a1t,a3dt,Jcoord)
        d3t = oEC.addEFp(ECG,a2t,m1m2h1t,Jcoord)
        d3 = oEC.toEFp(ECG,d3t,Jcoord)
        #d3p = (m2*a1.d)+(m1*a2.d)+a3.d+((m1*m2)*h1)
        #assert d3 == d3p
        return PPATSCommitment(d3,self)

    def __str__(self):
        return "PPATSPublicKey :\n"+str(self.PPATSpp)+"\n g1 :\n"+str(self.g1)+"\n h1 :\n"+str(self.h1)

class PPATSPrivateKey :
    def __init__(self,PPATSpp, PPATSpk, x1):
        self.PPATSpp = PPATSpp
        self.PPATSpk = PPATSpk
        assert self.PPATSpp ==  self.PPATSpk.PPATSpp
        self.x1 = x1 # the private key
        g = self.PPATSpp.g
        g1 = self.PPATSpk.g1
        assert g1 == g*self.x1
        self.psig = self.PPATSpp.psi(self.PPATSpp.g)
        self.eh1psig = self.PPATSpp.e(self.PPATSpk.h1,self.psig,self.PPATSpp.Pair)

        self.maxexp = self.PPATSpk.maxexp # limit for the extraction of the discrete log algorithm
        self.giantStepsDict = {} # dictionnary set up when using baby step-giant step algo

    def __eq__(self, other):
        return (self.x1 == other.x1 and self.PPATSpp == other.PPATSpp and self.PPATSpk == other.PPATSpk)

    def decrypt(self,c):
        limit = 2**self.maxexp
        def DLog(x,a):
            ''' Return y such as a**y = x
            '''
            if x == x.F.one():
                return 0
            elif a == x :
                return 1
            b = a
            for y in range(1,limit):
                b = a*b
                if b == x :
                    return y+1
            return None # case where y is not found

        def DLogOptim(x,a,dic={}):
            ''' Return y such as a**y = x using optimized methods in Fp12 to perform
            multiplications.
            The algorithm is base on the baby-step / giant-step method.
            The dictionnary dic stores the precomputed values of a needed for the
            algo. This dictionnary can be computed with the method self.giantSteps
            '''
            Pair = self.PPATSpp.Pair
            Fpk = Pair.Fpk
            gamma = Pair.gamma
            if x == x.F.one():
                return 0
            elif a == x :
                return 1
            order = self.PPATSpp.order
            b = oEC.toTupleFp12(a)
            xp = oEC.toTupleFp12(x)
            if dic == {}:
                if self.giantStepsDict == {}:
                    dic = self.giantSteps(b)
                    self.giantStepsDict = dic
            else :
                dic = self.giantStepsDict

            t = dic['t']
            # baby-step / giant-step algo
            for i in range(0,t+1):
                ai = dic['e1'][i]
                bi = oEC.tmulFp12(Fpk,xp,ai,gamma)
                if bi in dic['e2'].keys():
                    j = dic['e2'][bi]
                    return (j*t-i)%order #y
            return None # in case the value y is not found

        assert isinstance(c,PPATSCiphertext)
        #notations
        d = c.d.d.copy()
        c1 = c.c1.copy()
        c2 = c.c2.copy()
        #d.toAffine()
        #c1.toAffine()
        #c2.toAffine()
        h = self.PPATSpp.h
        e = self.PPATSpp.e
        Pair = self.PPATSpp.Pair
        psi = self.PPATSpp.psi
        psiop = psi(self.x1*c1-c2)

        mt= e(h,psiop,Pair)*e(d,self.psig,Pair)
        #print mt
        if self.PPATSpp.optim :
            return DLogOptim(mt,self.eh1psig,self.giantStepsDict)
        else :
            return DLog(mt,self.eh1psig)

    def opens(self,c):

        assert isinstance(c,PPATSCiphertext)

        #notations
        c1 = c.c1
        c2 = c.c2

        return c2-self.x1*c1

    def giantSteps(self,a):
        ''' This method computes a series of exponentiations of a.

            Assuming a is in Fq12.

            maxi is the maximum value of the possible discrete log to be found
            (by default 2**16).

            The method will precompute exponentiation of a at each of the t steps
            where t is the square root of maxi : a^0, a^t, a^2t, ..., a^maxi.

            In addition (not in the original algo but inserted here because 2^8 is
            a small number), the method computes a^0, a^1, a^2, ..., a^t.
            Since this is also needed to compute the discrete logarithm.

            Finally, all the precomputed exponentiations are stored in a dictionnary.
        '''
        limit = 2**self.maxexp
        Pair = self.PPATSpp.Pair
        gamma = Pair.gamma
        Fpk = Pair.Fpk
        t = int(math.sqrt(limit))
        l = int(limit//t)
        dic = {}
        dic['t'] = t # storing t for a later use
        at = oEC.squareAndMultiply(Fpk,a,t,oEC.tmulFp12,oEC.tsqrtFp12,gamma)
        one = oEC.toTupleFp12(Pair.Fpk1)
        dic['e1'] = {}
        dic['e2'] = {}
        dic['e1'][0] = one
        dic['e1'][1] = a
        dic['e2'][one] = 0
        dic['e2'][at] = 1
        ai = a
        ait = at
        # dic['e1'] is a dictionnary containing the a^i for i=0,...,t where the
        # keys are the indexes
        for i in range(2,t+1):
            ai = oEC.tmulFp12(Fpk,ai,a,gamma)
            dic['e1'][i] = ai
        # dic['e2'] is a dictionnary containing the a^it for i=0,...,l where the
        # keys are the a^it and the values are the indexes
        for i in range(2,l+1):
            ait = oEC.tmulFp12(Fpk,ait,at,gamma)
            dic['e2'][ait] = i
        return dic

    def __str__(self):
        return "PPATSPrivateKey :\n"+str(self.PPATSpp)+"\n "+str(self.PPATSpk)+"\n x1 :\n"+str(self.x1)

class PPATSCiphertext(fingexp.FingExp) :
    def __init__(self,d,c1,c2,PPATSpk):
        self.d = d
        self.c1 = c1
        self.c2 = c2
        self.PPATSpk = PPATSpk

        self.to_fingerprint = ["PPATSpk","d","c1","c2"]
        self.to_export = {"fingerprint": [],"value": ["PPATSpk","d","c1","c2"]}


    def __eq__(self,other):
        return (self.d == other.d and self.c1 == other.c1 and self.c2 == other.c2 and self.PPATSpk == other.PPATSpk)

    def __str__(self):
        #return "PPATSCiphertext :\n"+str(self.PPATSpk)+"\n d :\n"+str(self.d)+"\n c1 :\n"+str(self.c1)+"\n c2 :\n"+str(self.c2)
        return "PPATSCiphertext :\n\t"+str(self.d)+"\n\t c1 :\n\t"+str(self.c1)+"\n\t c2 :\n\t"+str(self.c2)

    def __repr__(self):
        return self.__str__()

    def __add__(self,b):
        ''' Addition between two PPATS ciphertext
            The result is a PPATS ciphertext which encrypts and commits
            on the sum of the initial messages
        '''
        assert isinstance(b,PPATSCiphertext)
        assert self.PPATSpk == b.PPATSpk # ciphertexts built using the same public key
        return PPATSCiphertext(self.d+b.d,self.c1+b.c1,self.c2+b.c2,self.PPATSpk)

    def __sub__(self,e):
        return self.__add__(-e)

    def __neg__(self):
        return PPATSCiphertext(-self.d,-self.c1,-self.c2,self.PPATSpk)

    def __mul__(self,e):
        '''multiplication by a scalar
           The result is a PPATS Ciphertext which encrypts and commits on e*m
        '''
        m = gmpy.mpz(1)
        if not isinstance(e, int) and not isinstance(e, long) and not type(e)==type(m):
            raise Exception("Multiplication of a PPATS Ciphertext by a non integer, long or mpz")
        else :
            return PPATSCiphertext(e*self.d,e*self.c1,e*self.c2,self.PPATSpk)

    def __rmul__(self, other):
        return self.__mul__(other)

class PPATSCommitment(fingexp.FingExp):
    def __init__(self,d,PPATSpk):
        self.d = d
        self.PPATSpk = PPATSpk

        self.to_fingerprint = ["PPATSpk","d"]
        self.to_export = {"fingerprint": [],"value": ["PPATSpk","d"]}

    def __eq__(self,other):
        if not isinstance(other,PPATSCommitment):
            return False
        else :
            return (self.d == other.d and self.PPATSpk == other.PPATSpk)

    def __str__(self):
        #return "PPATSCiphertext :\n"+str(self.PPATSpk)+"\n d :\n"+str(self.d)+"\n c1 :\n"+str(self.c1)+"\n c2 :\n"+str(self.c2)
        return "PPATSCommitment :\n\t"+str(self.d)

    def __repr__(self):
        return self.__str__()

    def __add__(self,e):
        ''' Addition between two PPATS commitments
            The result is a PPATS commitment which commits
            on the sum of the initial messages
        '''
        assert isinstance(e,PPATSCommitment)
        assert self.PPATSpk == e.PPATSpk # commitments built using the same public key
        return PPATSCommitment(self.d+e.d,self.PPATSpk)

    def addOptim(self,com):
        ECG = self.PPATSpk.h1.ECG
        Jcoord = self.PPATSpk.PPATSpp.Jcoord
        d1 = com.d
        dt = oEC.toTupleEFp(self.d,Jcoord)
        d1t = oEC.toTupleEFp(d1,Jcoord)
        st = oEC.addEFp(ECG,dt,d1t,Jcoord)
        s = oEC.toEFp(ECG,st,Jcoord)
        comp = PPATSCommitment(s,self.PPATSpk)
        return comp

    def __sub__(self,e):
        assert isinstance(e,PPATSCommitment)
        return self.__add__(-e)

    def __neg__(self):
        return PPATSCommitment(-self.d,self.PPATSpk)

    def __mul__(self,a):
        '''multiplication by a scalar a
           The result is a PPATS Commitment which encrypts and commits on a*m
        '''
        m = gmpy.mpz(1)
        if not isinstance(a, int) and not isinstance(a, long) and not type(a)==type(m):
            raise Exception("Multiplication of a PPATS Commitment by a non integer, long or mpz")
        else :
            return PPATSCommitment(a*self.d,self.PPATSpk)

    def __rmul__(self, other):
        return self.__mul__(other)
